## 1v1 Game Invites – Architecture & Flow

### 1. Goals

- Keep `chat-service` focused on **messaging + persistence**, not game logic.
- Let `room-service` own the **game invitation lifecycle** and rooms.
- Use **notification-service** only to signal “you have an invite / unread message”.
- Give the frontend a **clear, simple flow** from “Invite” click to game start.

---

## 1. Ownership & Responsibilities

- **chat-service**
  - Transports and stores messages (including `GAME_INVITE`).
  - Delivers messages over WebSocket.
  - Triggers notifications (via notification-service) when a new message/invite arrives.
  - Does **not** decide how games/rooms work.

- **room-service**
  - Source of truth for **game invitations** and **rooms**.
  - Manages invitation state: `pending → accepted/declined/expired`.
  - Creates rooms when an invitation is accepted.
  - Calls `game-service` to actually start a game.

- **game-service**
  - Creates and manages game instances.
  - Handles the game WebSocket (game state, moves, etc.).

- **notification-service**
  - Sends `NEW_MESSAGE` / `GAME_INVITE` notifications to clients.
  - Used by frontend to show **badges / indicators**, not the actual content.

---

## 2. Data Models (Conceptual)

### 2.1. Invitation (room-service)

```ts
type InvitationStatus = 'pending' | 'accepted' | 'declined' | 'expired' | 'cancelled';

interface GameInvitation {
  id: string;              // UUID
  inviterId: string;       // sender userId
  inviteeId: string;       // recipient userId
  status: InvitationStatus;
  roomId?: string;         // set when accepted
  mode?: 'DUEL' | 'RANKED' | 'CUSTOM';
  createdAt: Date;
  expiresAt: Date;         // e.g. now + 5min
}
```

> This lives in **room-service** (in-memory manager or Prisma model).

### 2.2. Chat message payload (chat-service)

```ts
// Stored in Message.payload when type === "GAME_INVITE"
interface GameInvitePayload {
  invitationId: string;    // generated by room-service
  mode?: 'DUEL' | 'RANKED' | 'CUSTOM';
}
```

### 2.3. Notification payload (notification-service)

```ts
// For GAME_INVITE notifications
{
  type: "GAME_INVITE",
  message: JSON.stringify({
    from: string,          // inviterId
    invitationId: string   // so frontend can link to invite
  })
}
```

---

## 3. APIs & Flows (Step-by-step)

### 3.1. Sender clicks “Invite to game” in chat UI

**Frontend → room-service**

```http
POST /api/v1/invitations
Authorization: Bearer <jwt>

{
  "inviteeId": "<target-user-id>",
  "mode": "DUEL"
}
```

**room-service:**

1. Validates inviter/invitee.
2. Creates `GameInvitation` with `status = "pending"`.
3. Returns:

```json
{
  "status": "success",
  "data": {
    "id": "invitation-id",
    "inviterId": "...",
    "inviteeId": "...",
    "status": "pending",
    "mode": "DUEL",
    "createdAt": "...",
    "expiresAt": "..."
  }
}
```

4. Calls **chat-service** (internal HTTP) to create & send the chat invite:

```http
POST /api/v1/chat/internal/invitation-created
x-service-token: <SERVICE_TOKEN>

{
  "invitationId": "invitation-id",
  "inviterId": "inviter-user-id",
  "inviteeId": "invitee-user-id",
  "mode": "DUEL"
}
```

**chat-service (internal handler):**

1. Persists a `Message` row:
   - `type: "GAME_INVITE"`
   - `payload: { invitationId, mode }`
2. Delivers this as WS message to `inviteeId` if online:

```ts
{
  type: "GAME_INVITE",
  from: inviterId,
  payload: { invitationId, mode },
  sentAt: "...iso..."
}
```

3. Triggers a `GAME_INVITE` notification via notification-service so the invitee sees a badge.

---

### 3.2. Recipient sees the invite

**Via chat WebSocket (`chat-service`):**

Frontend (invitee) receives:

```ts
{
  type: "GAME_INVITE",
  from: "inviter-user-id",
  payload: {
    invitationId: "invitation-id",
    mode: "DUEL"
  },
  sentAt: "..."
}
```

UI should:

- Show an **invite card/bubble** in that 1v1 chat:
  - “`<username>` invites you to a game (DUEL)”
  - Buttons: **Accept** / **Decline**

**Via notification-service WebSocket:**

- A `GAME_INVITE` notification arrives (used to show a badge even if chat tab is closed).

---

### 3.3. Recipient accepts or declines

#### Accept

**Frontend → room-service**

```http
POST /api/v1/invitations/:invitationId/accept
Authorization: Bearer <jwt>
```

**room-service:**

1. Validates:
   - Invitation exists, `status = "pending"`.
   - Not expired.
   - Current user is `inviteeId`.
2. Creates or uses a room:
   - e.g. `roomManager.createRoom(...)` and add both players.
3. Calls **game-service** to create a game for that room.
4. Updates invitation: `status = "accepted"`, `roomId = ...`.
5. Optionally broadcasts a room update / game start via notification-service.
6. Responds:

```json
{
  "status": "success",
  "data": {
    "roomId": "room-id",
    "gameId": "game-id"
  }
}
```

**Frontend (invitee):**

- Navigate to the game UI, e.g. `/game/:roomId` and open `game-service` WebSocket.

**Frontend (inviter):**

- Separately, they might receive a **room update** / **game start** notification and also navigate to the game UI.

#### Decline

**Frontend → room-service**

```http
POST /api/v1/invitations/:invitationId/decline
Authorization: Bearer <jwt>
```

**room-service:**

1. Validates invite & user.
2. Sets `status = "declined"`.
3. Optionally:
   - Sends a simple `CHAT` message back to inviter (“invite declined”).
   - Or sends a `GAME_INVITE_DECLINED` notification.

Frontend (inviter) can show “Invite declined” in chat.

---

## 4. Frontend Components & Responsibilities

### 4.1. Where to put the “Invite to game” button

In the **1v1 chat screen**:

- **Header**:
  - Next to the username/avatar: `Invite to game` button.
- **Message input area**:
  - Small controller icon / button beside send button: “Game invite”.

Click → open a small modal or directly call:

```ts
await fetch('/api/v1/invitations', {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
  body: JSON.stringify({ inviteeId: targetUserId, mode: 'DUEL' })
});
```

You **do not** call chat-service directly from the button; you talk to **room-service**, which then uses chat-service internally.

### 4.2. Rendering the invite in chat

When chat WebSocket receives `type: "GAME_INVITE"`:

- Render a special message component:

```tsx
<GameInviteMessage
  fromUserId={msg.from}
  invitationId={msg.payload.invitationId}
  mode={msg.payload.mode}
  onAccept={() => acceptInvitation(msg.payload.invitationId)}
  onDecline={() => declineInvitation(msg.payload.invitationId)}
/>;
```

**Accept handler:**

```ts
async function acceptInvitation(invitationId: string) {
  const res = await fetch(`/api/v1/invitations/${invitationId}/accept`, {
    method: 'POST',
    headers: { Authorization: `Bearer ${token}` }
  });
  const { data } = await res.json();
  // Navigate to game/room
  router.push(`/game/${data.roomId}`);
}
```

**Decline handler** is similar but calls `/decline` and just updates UI.

---

## 5. Chat-service Scope (What It Does / Doesn’t Do)

**Chat-service DOES:**
- Accept `GAME_INVITE` messages from **room-service internal endpoint**.
- Persist them as `Message` rows.
- Deliver them over WebSocket to the appropriate user.
- Trigger `GAME_INVITE` notifications via notification-service.

**Chat-service DOES NOT:**
- Know how rooms/games are created.
- Validate invitation business rules (expiry, duplicates, etc.).
- Manage invitation statuses beyond storing the corresponding message.

---

## 6. Summary

- **room-service** is the brain for game invitations and rooms.
- **chat-service** is just the transport and storage for `GAME_INVITE` messages.
- **notification-service** tells the client “you have a new invite/unread message”.
- **Frontend**:
  - Sends `POST /api/v1/invitations` when user clicks “Invite to game”.
  - Renders `GAME_INVITE` messages from chat WS with Accept/Decline.
  - Calls `/accept` or `/decline` on invitations.
  - Navigates into the game once room/game is ready.

This keeps concerns clean and follows the patterns already used in your other services.

